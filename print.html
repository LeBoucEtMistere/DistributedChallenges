<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Workshop Tutorial: Distributed Systems Challenges</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="00-intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="01-setup.html"><strong aria-hidden="true">1.</strong> Chapter 1: Setup</a></li><li class="chapter-item expanded "><a href="02-echo.html"><strong aria-hidden="true">2.</strong> Chapter 2: The Echo challenge</a></li><li class="chapter-item expanded "><a href="03-unique_id.html"><strong aria-hidden="true">3.</strong> Chapter 3: The Unique Id challenge</a></li><li class="chapter-item expanded "><a href="04-broadcast.html"><strong aria-hidden="true">4.</strong> Chapter 4: The Broadcast challenge</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04a-broadcast.html"><strong aria-hidden="true">4.1.</strong> Chapter 4a: Single node broadcast</a></li><li class="chapter-item expanded "><a href="04b-broadcast.html"><strong aria-hidden="true">4.2.</strong> Chapter 4b: Multi node broadcast</a></li></ol></li><li class="chapter-item expanded "><a href="A-cargo.html">Appendix A: Cargo Cheatsheet</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Workshop Tutorial: Distributed Systems Challenges</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This tutorial will walk you through solving Fly.io distributed challenges in Rust: <a href="https://fly.io/dist-sys/">https://fly.io/dist-sys/</a></p>
<p>This is intended as an entry-level content to discover Rust, hopefully easily approachable by complete Rust beginners.</p>
<p>The <a href="https://github.com/LeBoucEtMistere/DistributedChallenges">repo</a> structure is the following:</p>
<ul>
<li>The folder <a href="https://github.com/LeBoucEtMistere/DistributedChallenges/tree/main/distributed_challenges_solution">distributes_challenges_solution</a> contains a rust project with the full solution</li>
<li>The folder <a href="https://github.com/LeBoucEtMistere/DistributedChallenges/tree/main/distributed_challenges">distributes_challenges</a> contains the initial template to start the workshop </li>
<li>The folder <a href="https://github.com/LeBoucEtMistere/DistributedChallenges/tree/main/tutorial">tutorial</a> contains the sources of this book.</li>
<li>The folder <a href="https://github.com/LeBoucEtMistere/DistributedChallenges/tree/main/node_driver">node_driver</a> contains a library that handles all the things related to communication with Maelstrom in rust, that your solution shall depend on.</li>
</ul>
<p>Below are additional useful resources:</p>
<ul>
<li>The official rust book: <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a></li>
<li>Comprehensive Rust by Google: <a href="https://google.github.io/comprehensive-rust/">https://google.github.io/comprehensive-rust/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1-setup"><a class="header" href="#chapter-1-setup">Chapter 1: Setup</a></h1>
<p>In this first chapter, we will see how to setup a Rust toolchain from scratch, an IDE to develop Rust, and the Maelstrom testbench that we will use to evaluate your solutions to the various Distributed System challenges.</p>
<h2 id="rust-setup"><a class="header" href="#rust-setup">Rust setup</a></h2>
<h3 id="install-rust-toolchain"><a class="header" href="#install-rust-toolchain">Install Rust toolchain</a></h3>
<p>Rust is installed through <code>rustup</code>, an utility which manages your rust toolchain (like <code>nvm</code> for node for instance). Install it with: </p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>This repo builds on the latest stable version of Rust, <code>Rust 1.68</code>.
When installing rustup, it will prompt you to install the latest stable Rust version. If you already have rust installed, run <code>rustup upgrade</code> to get the latest version.</p>
<p>Note that as stated by the installer, you will need to export an env variable in your shell .rc file after the install process, and restart your shell to pick it up.</p>
<p>You can sanity check your installation by running <code>cargo --version</code>, more on cargo later.</p>
<p>You will also need to install the MacOS vendored LLVM compiler (it's possible you already have it, but it tends to disappear after a major MacOS upgrade): run <code>xcode-select --install</code>.</p>
<p>I also highly recommend to export these two env variables in your shell:</p>
<pre><code class="language-sh">export CARGO_NET_GIT_FETCH_WITH_CLI=true  # fixes issues with git that tend to happen with ssh
export CARGO_REGISTRIES_CRATES_IO_PROTOCOL=sparse  # makes git operations a lot faster, requires latest rust version
</code></pre>
<h3 id="setting-up-ide"><a class="header" href="#setting-up-ide">Setting up IDE</a></h3>
<p>I recommend VSCode for the easiest dev experience possible. We will configure it to leverage <code>rust-analyzer</code>, the official LSP server for Rust, <code>clippy</code> the official linter for Rust and <code>rustfmt</code> the official formatter for Rust.</p>
<p>Note that both <code>rustfmt</code> and <code>clippy</code> ship with the default Rust toolchain install so you don't have to do anything to get them.</p>
<p>To get <code>rust-analyzer</code>, we will install the VSCode integration called <code>rust-lang.rust-analyzer</code>. This extension will handle itself the process of downloading the binaries for <code>rust-analyzer</code> transparently.</p>
<p>I then recommend to alter your VSCode config (<code>Cmd+,</code>) and add the following keys:</p>
<pre><code class="language-json">{
    &quot;editor.formatOnSave&quot;: true,
    &quot;rust-analyzer.checkOnSave.command&quot;: &quot;clippy&quot;,
}
</code></pre>
<p>Here are some other additional extensions that will make your developer experience smoother:</p>
<ul>
<li><code>serayuzgur.crates</code> Augmented functionalities to manage the crates used in your project</li>
<li><code>tamasfe.even-better-toml</code> LSP for the TOML language which is often used with Rust</li>
<li><code>usernamehw.errorlens</code> Inline errors in your code, making it easier to see them in context</li>
</ul>
<h3 id="optional-installing-a-nightly-toolchain-for-nicer-formatting"><a class="header" href="#optional-installing-a-nightly-toolchain-for-nicer-formatting">Optional: installing a nightly toolchain for nicer formatting</a></h3>
<p>Some nice formatting options for your code are gated behind the nightly toolchain of Rust. In particular, the option to sort imports by type (std,3p,prj for instance). To get this, we can install the latest nightly toolchain using rustup (<code>rustup toolchain install nightly</code>). Then add the following in your vscode config file:</p>
<pre><code class="language-json">{
    &quot;rust-analyzer.rustfmt.extraArgs&quot;: [
        &quot;+nightly&quot;
    ],
}
</code></pre>
<p>This will force the usage of the formatter coming with the nightly toolchain (this does not mean your project will be compiled with the nightly toolchain though, only the formatter will use it).</p>
<p>Then, you can specify a <code>.rustfmt.toml</code> file at the root of your project with this content:</p>
<pre><code class="language-toml">group_imports = &quot;StdExternalCrate&quot;
</code></pre>
<h2 id="maelstrom-setup"><a class="header" href="#maelstrom-setup">Maelstrom setup</a></h2>
<p>The challenges we will solve are built on top of a platform called <a href="https://github.com/jepsen-io/maelstrom">Maelstrom</a>. This platform lets you build out a &quot;node&quot; in your distributed system and Maelstrom will handle the routing of messages between the those nodes. This lets Maelstrom inject failures and perform verification checks based on the consistency guarantees required by each challenge. You can see it as a simulator and test bench for developing distributed systems.</p>
<p>Maelstrom is built in Clojure and therefore requires the Java JDK to run. It also provides some plotting and graphing utilities which rely on Graphviz &amp; gnuplot. You can install all the required dependencies with this command:</p>
<pre><code class="language-bash">brew install openjdk graphviz gnuplot
</code></pre>
<p>You will need to tell your system about this java version by running</p>
<pre><code class="language-bash">sudo ln -sfn /opt/homebrew/opt/openjdk/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk.jdk
</code></pre>
<p>We are now ready to download Maelstrom binary, the following commands will install it under <code>~/maelstrom/maelstrom</code>:</p>
<pre><code class="language-bash">curl -L https://github.com/jepsen-io/maelstrom/releases/download/v0.2.3/maelstrom.tar.bz2 &gt; /tmp/maelstrom.tar.bz2
tar -C ~/ -xvf /tmp/maelstrom.tar.bz2
rm -rf /tmp/maelstrom.tar.bz2
</code></pre>
<p>Each problem will come with a set of Maelstrom commands to run it and test it so you don't have to worry on understanding all the parameters you can pass to the CLI.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-the-echo-challenge"><a class="header" href="#chapter-2-the-echo-challenge">Chapter 2: The Echo challenge</a></h1>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<p>You can find the challenge here: <a href="https://fly.io/dist-sys/1/">https://fly.io/dist-sys/1/</a></p>
<p>The goal of this challenge is to discover how to interact with Maelstrom and build a very basic echo server.</p>
<p>You should start by reading the challenge description to get a better sense of how Maelstrom works. Then, this tutorial will take you step-by-step through a Rust solution.</p>
<h2 id="forewords-working-with-maelstrom"><a class="header" href="#forewords-working-with-maelstrom">Forewords: working with Maelstrom</a></h2>
<p>In the challenge description, you'll note that the authors refer to a Go library they provide to easily interact with the Maelstrom nodes and clients. This repo provides you with a similar Rust library, located in the <code>node_driver</code> folder. It handles the initialization of your node, the communications over STDIN and STDOUT with Maelstrom, and the serialization and deserialization of the Messages.</p>
<p>We will explore this library as users in the tutorial, you can find the public documentation for this lib at <a href="https://distributed-challenges.vercel.app/">https://distributed-challenges.vercel.app/</a>. If you are getting confident with your Rust skills, I recommend taking some time later to explore this lib and see how it's coded.</p>
<h2 id="walkthrough"><a class="header" href="#walkthrough">Walkthrough</a></h2>
<h3 id="discovering-our-first-struct-and-enum"><a class="header" href="#discovering-our-first-struct-and-enum">Discovering our first <code>struct</code> and <code>enum</code></a></h3>
<p>Reading through the challenge guide, we see our node will receive <code>echo</code> messages that look something like that:</p>
<pre><code class="language-json">{
  &quot;src&quot;: &quot;c1&quot;,
  &quot;dest&quot;: &quot;n1&quot;,
  &quot;body&quot;: {
    &quot;type&quot;: &quot;echo&quot;,
    &quot;msg_id&quot;: 1,
    &quot;echo&quot;: &quot;Please echo 35&quot;
  }
}
</code></pre>
<p>(If you want more details on the protocol Maelstrom uses to transmit messages, see <a href="https://github.com/jepsen-io/maelstrom/blob/main/doc/protocol.md">this</a>)</p>
<p>As explained above, the <code>node_driver</code> library provides you everything you need to model such messages. Therefore, before writing any Rust, we will start by reading the documentation of this library, and more particularly the documentation of the <a href="https://distributed-challenges.vercel.app/node_driver/struct.Message.html">Message struct</a>.</p>
<p>This is our first encounter with a <code>struct</code>, the concept Rust uses to define aggregates of data. This is in a way very similar to C structs as you define your data and the behaviors to operate on it separately. Our data structure definition looks like this:</p>
<pre><code class="language-rust ignore">pub struct Message&lt;P&gt; {
    pub src: String,
    pub dst: String,
    pub body: Body&lt;P&gt;,
}</code></pre>
<p>The <code>pub</code> keyword at the struct level denotes that this is a public structure exposed by the library to its callers, while the <code>pub</code> keywords before each field of the struct denotes these fields are accessible from outside of the struct, this can be though of as visibility modifiers. Of course, the documentation only shows public fields and structs since they are the only ones we can interact with.</p>
<p>Each field is described as <code>field_name: field_type</code>.</p>
<p>We see two basic fields <code>src</code> and <code>dst</code>, of type String.</p>
<p>The last field type has a generic annotation (the <code>&lt;P&gt;</code> syntax, C++ users should feel pretty much at home here). It means that the <code>Message</code> struct is generic over a type, noted <code>P</code>, and here this type <code>P</code> is used in the definition of the type of the field <code>body</code>: a <code>Body&lt;P&gt;</code>. Let's look at the documentation for the type <code>Body</code> to understand what's going on here.</p>
<p>The <code>Body</code> struct is documented like this:</p>
<pre><code class="language-rust ignore">pub struct Body&lt;P&gt; {
    pub msg_id: Option&lt;usize&gt;,
    pub in_reply_to: Option&lt;usize&gt;,
    pub payload: P,
}</code></pre>
<p>There are two new things there: we see two fields that are of type <code>Option&lt;usize&gt;</code>, and the last field is of the type <code>P</code>, our generic type parameter. Let's explain each.</p>
<p><code>Option&lt;T&gt;</code> is another generic struct, in fact it comes from the Rust standard lib and is a staple of any Rust program, you can see the doc for this struct by clicking on it in the doc of the <code>Body</code> struct. This is actually an <code>enum</code> and not a <code>struct</code>, defined as:</p>
<pre><code class="language-rust ignore">pub enum Option&lt;T&gt; {
    None,
    Some(T),
}</code></pre>
<p>(note that all enum fields have the visibility of the enum so no need to add <code>pub</code> to each variant here)</p>
<p>So far this definition looks pretty similar to a classic Python enum, except, the second variant <code>Some</code> actually contains data, of type <code>T</code> (the generic parameter of the enum). This is what we call a <code>sum type</code> or an <code>algebraic type</code>: an enum that can contain different data types based on the variant. In our case, we use an <code>Option&lt;usize&gt;</code> which means that the data contained in the <code>Some</code> variant will be of type <code>usize</code> (a <code>usize</code> is an unsigned integer of the size of a pointer on your system, most likely 64 bits on a 64 bits system, for more details on basic scalar types, see <a href="https://google.github.io/comprehensive-rust/basic-syntax/scalar-types.html">this</a>), while the <code>None</code> variant contains nothing.</p>
<p>Algebraic types are one of the killer features of Rust, for more details, refer to the <a href="https://doc.rust-lang.org/book/ch06-00-enums.html">official rust book</a>. What's really important is that to get data out of your <code>Option</code> instance, you NEED to check if it's <code>None</code> or <code>Some</code> before, and the compiler will force you to do so. There is no way around this, and this prevents developers from accidentally forgetting that the result they deal with can be None. Python programmers will hopefully quickly realize how powerful this is, and how much safety it brings to the programs.</p>
<p>Let's go back at our <code>Body</code> struct and look at the <code>payload</code> field. We see it is of type <code>P</code>, the type over which our struct is generic. This means that we can stuff any type we want as a payload of our message, a <code>Message&lt;f64&gt;</code> will have a field body of type <code>Body&lt;f64&gt;</code> which in turns will have a field payload of type <code>f64</code>.</p>
<h3 id="defining-the-messages"><a class="header" href="#defining-the-messages">Defining the messages</a></h3>
<p>Armed with this knowledge, let's hop into our editor and start writing Rust to represent the <code>echo</code> messages. Open the file <code>distributed_challenges/src/bin/echo.rs</code>. You are faced with this:</p>
<pre><code class="language-rust ignore">fn main() -&gt; anyhow::Result&lt;()&gt; {
    todo!()
}</code></pre>
<p>This is a minimal Rust program, composed of a <code>main</code> function taking no arguments and returning a value of type <code>anyhow::Result&lt;()&gt;</code>. Let's not bother too much about this return type for now.
The corpus of the function is a single invocation of the <code>todo!()</code> macro. Any function postfixed with a <code>!</code> is what we call a <code>macro</code>. Let's not bother about this either, you can think of them as functions on steroids for now (If you want to know more, check out the <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">rust book</a>).</p>
<p>Let's define an enumeration to represent the payloads for the two messages our application will need to handle. Add this definition outside of the main function:</p>
<pre><code class="language-rust ignore">/// Defines the payload we want to send to clients in the echo challenge
enum EchoPayload {
    /// Used by clients to send an echo request
    Echo { echo: String },
    /// Used by nodes to respond to an echo request
    EchoOk { echo: String },
}</code></pre>
<p>We have two variants, one for each message, and each of them contains a string field called <code>echo</code> that will represent the data we are asked to echo back. (The <code>///</code> defines docstring of the fields, while <code>//</code> are regular non-documenting comments)</p>
<p>Let's make our enum a little bit easier to work with by adding some useful behaviors to it: <code>Debug</code> and <code>Clone</code>. The first one will allow us to print the enum content to debug it, and the second will make it so we can clone instances of the enum if we need to.
In fact, these &quot;behaviors&quot; are what we call in Rust <code>traits</code> (see <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">the official book</a> on this). A trait defines functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. This is in a way the interfaces of Rust, although it is much more powerful than this.</p>
<p>The <code>Debug</code> and <code>Clone</code> traits are provided by the Rust standard library: <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">https://doc.rust-lang.org/std/clone/trait.Clone.html</a> and <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">https://doc.rust-lang.org/std/fmt/trait.Debug.html</a>. We could manually implement it for our type if we wanted to do fancy things, but the compiler is smart enough to infer basic implementations of these traits for us and all we have to do to get it is to add this line on top of our enum:</p>
<pre><code class="language-rust ignore">/// Defines the payload we want to send to clients in the echo challenge
#[derive(Debug, Clone)]
enum EchoPayload {
    /// Used by clients to send an echo request
    Echo { echo: String },
    /// Used by nodes to respond to an echo request
    EchoOk { echo: String },
}</code></pre>
<p>This tells the Rust compiler to generate an implementation of both the <code>Clone</code> and <code>Debug</code> traits for the <code>EchoPayload</code> enum, this is what we call &quot;deriving traits&quot;. Here this work because Rust already ships a default implementation of these traits for all the types contained in our enumeration (<code>String</code> in this case).</p>
<h3 id="implementing-the-main-loop-of-our-server"><a class="header" href="#implementing-the-main-loop-of-our-server">Implementing the main loop of our server</a></h3>
<p>Now that we have a payload enum, let's start writing the logic of our server. In the main, let's first initialize our Malestrom client:</p>
<pre><code class="language-rust ignore">use node_driver::Maelstrom;

// ... snip ...

fn main() -&gt; anyhow::Result&lt;()&gt; {
    // init our node by getting its metadata and an output and input interface to communicate
    let (node_metadata, input, output) = Maelstrom::init()?;

    Ok(())
}</code></pre>
<p>There's a bunch of new concepts here:</p>
<ul>
<li>we add a <code>use</code> statement to import the <code>Maelstrom</code> type from the <code>node_driver</code> lib.</li>
<li>we define variables using the <code>let</code> keyword.</li>
<li>we call the <code>init</code> class method of the <code>Maelstrom</code> struct using the <code>Maelstrom::init()</code> syntax.</li>
<li>we use the <code>?</code> sigil to bubble up errors returned by the <code>init()</code> method to the output of the <code>main</code> function (you now see why we return a Result over the null type <code>()</code> as our main return type). If you look at the signature of the <code>init()</code> method in the documentation, you'll see it returns a <code>Result&lt;(NodeMetadata, InputInterface, OutputInterface)&gt;</code> and not just the tuple <code>(NodeMetadata, InputInterface, OutputInterface)</code>, a <code>Result</code> is also a sum type, very similar to <code>Option&lt;T&gt;</code>, which allows us to denote if a function errored out or if it returned a result.</li>
<li>statements finish with a <code>;</code> while expressions don't, and if the last line of a function is an expression, it is returned automatically. You can also use the statement syntax <code>return Ok(());</code> but it is less idiomatic. For more details on expressions vs. statements, see <a href="https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/functions.html#expressions-vs-statements">this article</a>.</li>
</ul>
<p>You'll see that if you remove the <code>?</code> sigil for instance, running <code>cargo build</code> or <code>cargo check</code> will give you a clear compiler error that the type don't match and that you need to ensure the result returned by the <code>init</code> method is not an error. This is what the <code>?</code> sigil does, it bubbles up any error and if there is none, it &quot;unwrap&quot; the data out of the Result type. I encourage you to try stuff and read compiler errors, they have been designed to be as informative as possible and explain properly the source of your issue and how to solve it.</p>
<p>Now that our node is initialized, we can add our main loop over the incoming messages:</p>
<pre><code class="language-rust ignore">// ... snip ...

fn main() -&gt; anyhow::Result&lt;()&gt; {
    // init our node by getting its metadata and an output and input interface to communicate
    let (node_metadata, input, output) = Maelstrom::init()?;

    // main loop: for each message we receive through the input interface (with a payload of type EchoPayload)
    for msg in input.iter::&lt;EchoPayload&gt;() {

    }

    Ok(())
}</code></pre>
<p>We see here a for loop with no body yet. We loop over the content of <code>input.iter::&lt;EchoPayload&gt;()</code>, let's decipher this. Our <code>input</code> object, of type <code>InputInterface</code>, has a method called <code>iter&lt;P&gt;()</code> which produces an iterator over items of type <code>Result&lt;Message&lt;P&gt;&gt;</code>. However, if we just wrote <code>for msg in input.iter()</code>, the compiler cannot infer which type of item it should be producing because it can't infer what <code>P</code> should be in this context. Therefore we use the &quot;turbofish&quot; syntax <code>::&lt;&gt;</code> (yes, this is a fish going fast) to disambiguate the call to <code>iter</code> and specify that <code>P</code> should be <code>EchoPayload</code> in our case.</p>
<p>However, if you try to compile this program with <code>cargo build</code>, you will be faced with errors:</p>
<pre><code class="language-ignore">error[E0277]: the trait bound `for&lt;'de&gt; EchoPayload: serde::de::Deserialize&lt;'de&gt;` is not satisfied
  --&gt; distributed_challenges/src/bin/echo.rs:17:29
   |
17 |     for msg in input.iter::&lt;EchoPayload&gt;() {}
   |                             ^^^^^^^^^^^ the trait `for&lt;'de&gt; serde::de::Deserialize&lt;'de&gt;` is not implemented for `EchoPayload`
   |
   = help: the following other types implement trait `serde::de::Deserialize&lt;'de&gt;`:
             &amp;'a Path
             &amp;'a [u8]
             &amp;'a str
             ()
             (T0, T1)
             (T0, T1, T2)
             (T0, T1, T2, T3)
             (T0, T1, T2, T3, T4)
           and 129 others
   = note: required for `EchoPayload` to implement `serde::de::DeserializeOwned`
note: required by a bound in `InputInterface::iter`
  --&gt; /Users/arthur.depasse/perso/DistributedChallenges/node_driver/src/lib.rs:98:12
   |
98 |         P: DeserializeOwned,
   |            ^^^^^^^^^^^^^^^^ required by this bound in `InputInterface::iter`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `distributed_challenges` due to previous error
</code></pre>
<p>This looks rather cryptic at first, but you'll see it's actually a treasure trove of information to fix our error.</p>
<h3 id="fulfilling-trait-bounds"><a class="header" href="#fulfilling-trait-bounds">Fulfilling trait bounds</a></h3>
<p>Looking at the error message, we can read the following:</p>
<pre><code class="language-ignore">the trait bound `for&lt;'de&gt; EchoPayload: serde::de::Deserialize&lt;'de&gt;` is not satisfied
   |
17 |     for msg in input.iter::&lt;EchoPayload&gt;() {}
   |                             ^^^^^^^^^^^ the trait `for&lt;'de&gt; serde::de::Deserialize&lt;'de&gt;` is not implemented for `EchoPayload`
   |
...
note: required by a bound in `InputInterface::iter`
...
   |
98 |         P: DeserializeOwned,
   |            ^^^^^^^^^^^^^^^^ required by this bound in `InputInterface::iter`
</code></pre>
<p>This tells us that we are not fulfilling a constraint imposed by the <code>iter()</code> function. Let's look at its documentation:</p>
<p>This definition of the payload is not enough though. Let's have a look at the documentation of the <code>node_driver</code> lib and in particular, how to send a message with it: <a href="https://distributed-challenges.vercel.app/node_driver/struct.OutputInterface.html#implementations">https://distributed-challenges.vercel.app/node_driver/struct.OutputInterface.html#implementations</a>. In here we see this special syntax for the <code>send_msg</code> function:</p>
<pre><code class="language-rust ignore">pub fn iter&lt;P&gt;(&amp;mut self) -&gt; impl Iterator&lt;Item = Result&lt;Message&lt;P&gt;&gt;&gt; + '_
where
    P: DeserializeOwned,</code></pre>
<p>It's admittedly a bit hairy because it is very explicit, but the interesting part for us is what comes after the <code>where</code> clause: <code>P: DeserializeOwned</code>. This is what we call a trait bound, the function enforces that any generic type <code>P</code> we use with it must at least implement the <code>DeserializeOwned</code> trait. This is a very important mechanisms that let's us do some kind of compile-time polymorphism: we can call iter with any type as long as we know it implement this interface. In this case, we need to enforce the message can be deserialized into an owned <code>Message&lt;P&gt;</code>.</p>
<p>Note: this <code>DeserializeOwned</code> trait is not coming from the standard Rust library but from another lib called <code>serde</code> that provides utils for serializing and deserializing data structures in a multitude of formats.</p>
<p>If we also look at <a href="https://distributed-challenges.vercel.app/node_driver/struct.OutputInterface.html#method.send_msg">the function we use to send messages back</a>, we see it has a bound as well, <code>P</code> must implement <code>Serialize</code>.</p>
<p>Therefore, let's implement both <code>serde::Serialize</code> and <code>serde:Deserialize</code> for our payload type (in our case implementing <code>Deserialize</code> is enough to get <code>DeserializeOwned</code>, for reasons we won't detail here).</p>
<p>We could implement these traits by hand but fortunately, <code>serde</code> comes with a feature that allows us to use the helpful <code>derive</code> statement to auto-implement them for struct that only contain data that also implement them (which is the case here, all default data types implement them).</p>
<pre><code class="language-rust ignore">use serde::{Serialize, Deserialize}
/// Defines the payload we want to send to clients in the echo challenge
#[derive(Debug, Clone, Serialize, Deserialize)]
enum EchoPayload {
    /// Used by clients to send an echo request
    Echo { echo: String },
    /// Used by nodes to respond to an echo request
    EchoOk { echo: String },
}</code></pre>
<p>And now the error magically goes away as our Payload type meets the conditions required to deserialize it from a Maelstrom STDIN message.</p>
<p>We still have one error left though:</p>
<pre><code class="language-ignore">error[E0596]: cannot borrow `input` as mutable, as it is not declared as mutable
  --&gt; distributed_challenges/src/bin/echo.rs:18:16
   |
18 |     for msg in input.iter::&lt;EchoPayload&gt;() {}
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable
   |
help: consider changing this to be mutable
   |
15 |     let (node_metadata, mut input, output) = Maelstrom::init()?;
   |                         +++
</code></pre>
<p>This one can also be explained by looking at the signature of the <code>input</code> method:</p>
<pre><code class="language-rust ignore">pub fn iter&lt;P&gt;(&amp;mut self) -&gt; impl Iterator&lt;Item = Result&lt;Message&lt;P&gt;&gt;&gt; + '_
where
    P: DeserializeOwned,</code></pre>
<p>Notice the <code>&amp;mut</code> modifier in front of <code>self</code>? This means this method will act on a self that is a <code>mutable reference</code> to the instance it's called on. This means that <code>self</code> is not passed by value but by reference, and that this reference is an exclusive mutable reference that allows the user to modify the <code>InputInterface</code> instance represented by <code>self</code>.</p>
<p>Our error comes from the fact that variables in Rust are immutable by default. Because of this, <code>input</code> can only be dereferenced to <code>&amp;self</code> when calling <code>iter</code>, and not <code>&amp;mut self</code>.
We can simply fix that by adding the <code>mut</code> modifier to the definition of let to allow mutability. In fact, let's add it to <code>output</code> and <code>node_metadata</code> as well since we will also need them to be mutable in the future. Note that the error message suggests you a fix for this error.</p>
<pre><code class="language-rust ignore">    // init our node by getting its metadata and an output and input interface to communicate
    let (mut node_metadata, mut input, mut output) = Maelstrom::init()?;</code></pre>
<p>There is one final touch we need to make to our <code>EchoPayload</code> before jumping to filling out the loop body. Indeed as stated in the documentation of the <a href="https://distributed-challenges.vercel.app/node_driver/struct.Body.html#structfield.payload">body payload</a> and the <a href="https://github.com/jepsen-io/maelstrom/blob/main/doc/protocol.md">Maelstrom protocol</a>, we need to make sure our json payload we ultimately send contains a <code>type</code> field, which we haven't added to our enum variants.</p>
<p>There is a neat trick to do it automatically, based on the name of the variant, using <code>serde</code> annotations:</p>
<pre><code class="language-rust ignore">/// Defines the payload we want to send to clients in the echo challenge
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = &quot;type&quot;)]
#[serde(rename_all = &quot;snake_case&quot;)]
enum EchoPayload {
    /// Used by clients to send an echo request
    Echo { echo: String },
    /// Used by nodes to respond to an echo request
    EchoOk { echo: String },
}</code></pre>
<p>Note we added two <code>#[serde(...)]</code> annotations to our enum. The first one asks serde to use an internal tag field to hold the enum variant, and to name this field <code>type</code>, which serde will populate with the variant's name. The second tells serde to automatically rename all variants using snake_case, which will give us our <code>&quot;type&quot; = &quot;echo&quot;</code> and <code>&quot;type&quot; = &quot;echo_ok&quot;</code> in our json messages. For more details on handling of enums in <code>serde</code>, look at <a href="https://serde.rs/enum-representations.html">https://serde.rs/enum-representations.html</a></p>
<p>We end up with the following code at this point:</p>
<pre><code class="language-rust ignore">use node_driver::Maelstrom;
use serde::{Deserialize, Serialize};

/// Defines the payload we want to send to clients in the echo challenge
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = &quot;type&quot;)]
#[serde(rename_all = &quot;snake_case&quot;)]
enum EchoPayload {
    /// Used by clients to send an echo request
    Echo { echo: String },
    /// Used by nodes to respond to an echo request
    EchoOk { echo: String },
}

fn main() -&gt; anyhow::Result&lt;()&gt; {
    // init our node by getting its metadata and an output and input interface to communicate
    let (mut node_metadata, mut input, mut output) = Maelstrom::init()?;

    // main loop: for each message we receive through the input interface (with a payload of type EchoPayload)
    for msg in input.iter::&lt;EchoPayload&gt;() {}

    Ok(())
}</code></pre>
<h3 id="finish-implementing-the-main-loop"><a class="header" href="#finish-implementing-the-main-loop">Finish implementing the main loop</a></h3>
<p>It's now time to code the logic to react to the messages we receive.</p>
<p>First, we need to extract the message out of the <code>Result&lt;Message&lt;EchoPayload&gt;&gt;</code> returned by our iterator:</p>
<pre><code class="language-rust ignore">fn main() -&gt; anyhow::Result&lt;()&gt; {
    // init our node by getting its metadata and an output and input interface to communicate
    let (mut node_metadata, mut input, mut output) = Maelstrom::init()?;

    // main loop: for each message we receive through the input interface (with a payload of type EchoPayload)
    for msg in input.iter::&lt;EchoPayload&gt;() {}
        // if there was an error getting this message, propagate it (with the ? sigil)
        let msg = msg?;
    Ok(())
}</code></pre>
<p>Here we do a nice thing, we shadow the variable name <code>msg</code> by extracting the content or bubbling up any error using <code>?</code>. After this line, the type of <code>msg</code> is no longer <code>Result&lt;Message&lt;EchoPayload&gt;&gt;</code> but <code>Message&lt;EchoPayload&gt;</code> which simplifies our code.</p>
<p>Now, we will use a <code>match</code> statement to react differently to all the possible variants of the payload contained in the message:</p>
<pre><code class="language-rust ignore">    // main loop: for each message we receive through the input interface (with a payload of type EchoPayload)
    for msg in input.iter::&lt;EchoPayload&gt;() {
        // if there was an error getting this message, propagate it (with the ? sigil)
        let msg = msg?;
        // match on the type of payload within the message, these are variants of the EchoPayload enum
        match msg.body.payload {
            // if we get an Echo message, let's reply by crafting an EchoOk message and sending it through the output interface
            EchoPayload::Echo { echo } =&gt; todo!(),
            // we are not supposed to receive and EchoOk message, let's panic when it happens
            EchoPayload::EchoOk { .. } =&gt; panic!(&quot;EchoOk message shouldn't be received by a node&quot;),
        };
    }</code></pre>
<p><code>match</code> statements are one of the killer features of Rust, they are really powerful, support pattern matching, and need to be exhaustive.</p>
<p>Here we match on <code>msg.body.payload</code> which is of type <code>EchoPayload</code>, each arm of the match statement if of the form <code>pattern =&gt; expression,</code> or <code>pattern =&gt; statement,</code>.
We use simple patterns here, one for each possible variant. In the first one, we use the pattern to deconstruct the <code>echo</code> field within the variant since we will need it to craft the response. In the second arm, we don't need it so we elide the deconstruction with the <code>..</code>.
Finally, the second match arm is not supposed to happen in normal operations, so when it does we simply invoke the <code>panic!()</code> macro that will safely exit the program with an error message.</p>
<p>Finally, let's complete the first match arm and send a response message:</p>
<pre><code class="language-rust ignore">// ...
match msg.body.payload {
    EchoPayload::Echo { echo } =&gt; output.send_msg(Message {
        src: node_metadata.node_id.clone(),
        dst: msg.src,
        body: Body {
            msg_id: Some(node_metadata.get_next_msg_id()),
            in_reply_to: msg.body.msg_id,
            payload: EchoPayload::EchoOk { echo },
        },
    })?,
    /// ...</code></pre>
<p>This version is written concisely, but we could have made it a little clearer to new rustaceans by using a <code>{}</code> expression block here:</p>
<pre><code class="language-rust ignore">match msg.body.payload {
    EchoPayload::Echo { echo } =&gt; {
        let response = Message {
            src: node_metadata.node_id.clone(),
            dst: msg.src,
            body: Body {
                msg_id: Some(node_metadata.get_next_msg_id()),
                in_reply_to: msg.body.msg_id,
                payload: EchoPayload::EchoOk { echo },
            }
        };
        output.send_msg(response)?
    },
    /// ...</code></pre>
<p>We see that we instantiate a <code>Message</code> with an <code>EchoOk</code> payload, obtain a new message id from our <code>NodeMetadata</code> instance, and use our output interface to send it.</p>
<p>You should end up with the following code:</p>
<pre><code class="language-rust ignore">use node_driver::{Body, Maelstrom, Message};
use serde::{Deserialize, Serialize};

/// Defines the payload we want to send to clients in the echo challenge
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = &quot;type&quot;)]
#[serde(rename_all = &quot;snake_case&quot;)]
enum EchoPayload {
    /// Used by clients to send an echo request
    Echo { echo: String },
    /// Used by nodes to respond to an echo request
    EchoOk { echo: String },
}

fn main() -&gt; anyhow::Result&lt;()&gt; {
    // init our node by getting its metadata and an output and input interface to communicate
    let (mut node_metadata, mut input, mut output) = Maelstrom::init()?;
    // main loop: for each message we receive through the input interface (with a payload of type EchoPayload)
    for msg in input.iter::&lt;EchoPayload&gt;() {
        // if there was an error getting this message, propagate it (with the ? sigil)
        let msg = msg?;
        // match on the type of payload within the message, these are variants of the EchoPayload enum
        match msg.body.payload {
            // if we get an Echo message, let's reply by crafting an EchoOk message and sending it through the output interface
            EchoPayload::Echo { echo } =&gt; output.send_msg(Message {
                src: node_metadata.node_id.clone(),
                dst: msg.src,
                body: Body {
                    msg_id: Some(node_metadata.get_next_msg_id()),
                    in_reply_to: msg.body.msg_id,
                    payload: EchoPayload::EchoOk { echo },
                },
            })?,
            // we are not supposed to receive and EchoOk message, let's panic when it happens
            EchoPayload::EchoOk { .. } =&gt; panic!(&quot;EchoOk message shouldn't be received by a node&quot;),
        };
    }
    Ok(())
}</code></pre>
<h3 id="testing-our-solution"><a class="header" href="#testing-our-solution">Testing our solution</a></h3>
<p>It's now time to test our solution using Maelstrom:</p>
<pre><code class="language-bash">cargo build
~/maelstrom/maelstrom test -w echo --bin target/debug/echo --node-count 1 --time-limit 10
</code></pre>
<p>If it all goes well, you should ultimately see this message:</p>
<pre><code class="language-ignore">Everything looks good! ヽ(‘ー`)ノ
</code></pre>
<p>Congrats, you finished Challenge 1!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-the-unique-id-challenge"><a class="header" href="#chapter-3-the-unique-id-challenge">Chapter 3: The Unique Id challenge</a></h1>
<h2 id="explanation-1"><a class="header" href="#explanation-1">Explanation</a></h2>
<p>You can find the challenge here: <a href="https://fly.io/dist-sys/2/">https://fly.io/dist-sys/2/</a></p>
<p>The goal of this challenge is to generate unique ids across several nodes. There are two approaches to this solution:</p>
<ul>
<li>let the nodes communicate between them to sync (complex)</li>
<li>generate ids with enough entropy to avoid collisions between two generation no matter the node (easy)</li>
</ul>
<p>We will follow the second approach and rely on <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUIDs</a> generation algorithms, and more specifically UUIDs V4.</p>
<h2 id="walkthrough-1"><a class="header" href="#walkthrough-1">Walkthrough</a></h2>
<p>The code will be very similar to the Echo challenge code, so feel free to copy and paste and try it by yourself if you want, the only new concepts will be around importing a library (a crate in rust lingua) in our project, but other than this, you already have all the knowledge to reach the last section of this chapter by yourself.</p>
<h3 id="defining-the-message-payloads"><a class="header" href="#defining-the-message-payloads">Defining the message payloads</a></h3>
<p>Let's start by defining the messages we want to receive and send, based on the description provided by the challenge:
We have a Generate request with the following body</p>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;generate&quot;
}
</code></pre>
<p>and a GenerateOk response with the following body:</p>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;generate_ok&quot;,
  &quot;id&quot;: &quot;123&quot;
}
</code></pre>
<p>(note the id can be of any type but we will stick with a string here since that's what UUIDs use)</p>
<p>Therefore, we will write the following enum to describe the payloads our application can deal with:</p>
<pre><code class="language-rust ignore">#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = &quot;type&quot;)]
#[serde(rename_all = &quot;snake_case&quot;)]
enum UniqueIdPayload {
    /// Used by clients to send a generate request
    Generate,
    /// Used by nodes to respond to a generate request, we use a string typed ID since we
    /// will return uuid-v4
    GenerateOk { id: String },
}</code></pre>
<p>As in the previous part, you can note the various annotations on the enum to derive the common basic traits <code>Debug</code> and <code>Clone</code>, and the traits related to ser/de <code>Serialize</code> and <code>Deserialize</code>. These generate all the base scaffolding code under the hood to enable this enum variants to be easily displayed, cloned, serialized and deserialized (to json in particular which is what we care for here). There also are <code>serde</code> relative annotations to internally tag the enum variants with a type field, and rename all variants to a snake_case format. This basically gives us the required <code>type = </code> field in the json payload.</p>
<p>We have two variants, Generate representing generate requests, which doesn't contain any data, and GenerateOk representing a response to this request, that contains a field named <code>id</code> of type String.</p>
<p>As in the previous part, this payload enum is made to be inserted in the payload field of the <code>Message</code> type provided by the <code>node_driver</code> lib.</p>
<h3 id="writing-the-main-loop"><a class="header" href="#writing-the-main-loop">Writing the main loop</a></h3>
<p>Now that we have our definition of the message payloads, let's start writing the main loop logic.
As in the previous part, we need to start by initializing our Maelstrom node (don't hesitate to look again at the documentation of the library at <a href="https://distributed-challenges.vercel.app/">https://distributed-challenges.vercel.app/</a>):</p>
<pre><code class="language-rust ignore">fn main() -&gt; anyhow::Result&lt;()&gt; {
    // init our node by getting its metadata and an output and input interface to communicate
    let (mut node_metadata, mut input, mut output) = Maelstrom::init()?;
}</code></pre>
<p>This gets us our input and output interfaces and the node metadata (that we also won't use much in this challenge).</p>
<p>Let's start listening to incoming messages by looping on a blocking iterator on the messages received:</p>
<pre><code class="language-rust ignore">fn main() -&gt; anyhow::Result&lt;()&gt; {
    // init our node by getting its metadata and an output and input interface to communicate
    let (mut node_metadata, mut input, mut output) = Maelstrom::init()?;
    // main loop: for each message we receive through the input interface (with a payload of type UniqueIdPayload)
    for msg in input.iter::&lt;UniqueIdPayload&gt;() {
        // if there was an error getting this message, propagate it (with the ? sigil)
        let msg = msg?;

        todo!()
    }
}</code></pre>
<p>This time, we specify we want to receive messages with a payload of the type <code>UniqueIdPayload</code> that we just defined. We still have a line to propagate any error coming from the parsing/reception of the message.</p>
<p>We can now match on this message and define how we want to react to each variants. We will again use a <code>match</code> statement to do so:</p>
<pre><code class="language-rust ignore">    // match on the type of payload within the message, these are variants of the UniqueIdPayload enum
    match msg.body.payload {
        // if we get a Generate message, let's reply by crafting an GenerateOk message and sending it through the output interface
        UniqueIdPayload::Generate =&gt; todo!(),
        // we are not supposed to receive a GenerateOk message, let's panic when it happens
        UniqueIdPayload::GenerateOk { .. } =&gt; {
            panic!(&quot;GenerateOk message shouldn't be received by a node&quot;)
        }
    };</code></pre>
<p>We already know we are not supposed to receive any <code>GenerateOk</code> message, so let's panic with a clear error message when this happens. Keep in mind a panic is a controlled exit of the program, that should be used when we are faced with an unrecoverable error. One could argue we should just ignore the invalid message but panicking on it could help us catch errors if we were to implement our own clients.</p>
<p>Let's no complete the match arm associated with the <code>Generate</code> message. We know we want to build a <code>GenerateOk</code> message with a new UUID and send it through our output interface:</p>
<pre><code class="language-rust ignore">    // match on the type of payload within the message, these are variants of the UniqueIdPayload enum
    match msg.body.payload {
        // if we get a Generate message, let's reply by crafting an GenerateOk message and sending it through the output interface
        UniqueIdPayload::Generate =&gt; output.send_msg(msg.to_response(
                Some(node_metadata.get_next_msg_id()), // obtain the next message id
                UniqueIdPayload::GenerateOk {
                    // let's generate a uuid v4 using the uuid crate
                    id: todo!(),
                },
            ))?,
        // we are not supposed to receive a GenerateOk message, let's panic when it happens
        UniqueIdPayload::GenerateOk { .. } =&gt; {
            panic!(&quot;GenerateOk message shouldn't be received by a node&quot;)
        }
    };</code></pre>
<h3 id="generating-a-uuid"><a class="header" href="#generating-a-uuid">Generating a UUID</a></h3>
<p>The last missing part is now to generate an UUID. To do so, we will add a new dependency to our project, what is called a <code>crate</code> in Rust lingua: a small unit of shared code. Rust has first class support for easily managing dependencies of your project, through the <code>cargo</code> CLI, using a central crate registry: <a href="https://crates.io">crates.io</a></p>
<p>The dependency we want to use is <a href="https://crates.io/crates/uuid">uuid</a>. On this page you can see several important information on the crate:</p>
<ul>
<li>its version</li>
<li>some explanations and examples of what it does</li>
<li>how to install it</li>
<li>links to the documentation of this crate and its repository</li>
</ul>
<p>Let's add this crate to our project:</p>
<pre><code class="language-bash">cargo add uuid -p distributed_challenges --features v4
</code></pre>
<p>This command tells cargo to add the crate <code>uuid</code> to our project, in the package <code>distributed_challenges</code>, with the feature <code>v4</code>. We need to specify which package to install it into since we are working in a cargo workspace, i.e. a collection of several rust packages (c.f. <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">the official documentation for more info on workspaces</a>). The <code>--features</code> flag lets us specify which features we want to use. Features are functionalities of the crate that are not shipped by default (often to avoid bloating your binary if you don't explicitly need some things), and that we can opt-in. Here we need to opt-in the <code>v4</code> feature to have the part of the lib responsible for generating UUIDs V4.</p>
<p>Note that after running this command, you should see this modification reflected in the <code>Cargo.toml</code> file at the root of the package <code>distributed_challenges</code>. Feel free to have a look at the other dependencies we reference there, some are inherited from global workspace dependencies, some are path-based dependencies, etc..</p>
<p>Now that we have this new dependency, let's use it. A good idea is always to start by looking at its documentation so let's visit <a href="https://docs.rs/uuid/latest/uuid/">https://docs.rs/uuid/latest/uuid/</a>.
Here we can see the minimal snippet of code to generate a <code>Uuid</code> object:</p>
<pre><code class="language-rust ignore">use uuid::Uuid;

let id = Uuid::new_v4();</code></pre>
<p>Remember we ultimately need a String to put in our message, so let's navigate to the doc page of the <code>Uuid</code> structure to see if there are any methods or traits it implements that lets us convert it to a String: <a href="https://docs.rs/uuid/latest/uuid/struct.Uuid.html#impl-ToString-for-Uuid">https://docs.rs/uuid/latest/uuid/struct.Uuid.html#impl-ToString-for-Uuid</a>. We observe that the type implements the <code>ToString</code> trait that exposes the <code>to_string</code> method. Let's use it to complete our code:</p>
<pre><code class="language-rust ignore">// match on the type of payload within the message, these are variants of the UniqueIdPayload enum
    match msg.body.payload {
        // if we get a Generate message, let's reply by crafting an GenerateOk message and sending it through the output interface
        UniqueIdPayload::Generate =&gt; output.send_msg(msg.to_response(
                Some(node_metadata.get_next_msg_id()), // obtain the next message id
                UniqueIdPayload::GenerateOk {
                    // let's generate a uuid v4 using the uuid crate
                    id: uuid::Uuid::new_v4().to_string(),
                },
            ))?,
        // we are not supposed to receive a GenerateOk message, let's panic when it happens
        UniqueIdPayload::GenerateOk { .. } =&gt; {
            panic!(&quot;GenerateOk message shouldn't be received by a node&quot;)
        }
    };</code></pre>
<p>Note that this time, instead of creating our <code>Message</code> instance manually, we used the utility method <code>to_response</code> implement on the <code>Message</code> type, which makes our code more concise.</p>
<h3 id="testing-our-code"><a class="header" href="#testing-our-code">Testing our code</a></h3>
<p>It's now time to build and test our code to verify if we succeeded. First let's run <code>cargo build</code> to build a debug binary of our program (if you run this from the root of the workspace, it will rebuild all packages that need it, you can always only rebuild the <code>unique_id</code> one using the <code>-p</code> flag of <code>cargo build</code>). This should generate a new binary: <code>target/debug/unique_id</code>.</p>
<p>Let's now invoke Maelstrom on it to see if we solved the challenge:</p>
<pre><code class="language-bash">~/maelstrom/maelstrom test -w unique-ids --bin ./target/debug/unique_id --time-limit 30 --rate 1000 --node-count 3 --availability total --nemesis partition
</code></pre>
<p>If everything goes well, you should see</p>
<pre><code class="language-ignore">Everything looks good! ヽ(‘ー`)ノ
</code></pre>
<p>Congrats!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4-the-broadcast-challenge"><a class="header" href="#chapter-4-the-broadcast-challenge">Chapter 4: The Broadcast challenge</a></h1>
<p>You can find the challenge here: <a href="https://fly.io/dist-sys/3a/">https://fly.io/dist-sys/3a/</a></p>
<p>The goal of this challenge is to build a system that supports broadcasting information across its nodes. This is the first task that will require cross-node communication and because it introduces a lot of complexity, it is divided in several parts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4a-single-node-broadcast"><a class="header" href="#chapter-4a-single-node-broadcast">Chapter 4a: Single node broadcast</a></h1>
<p>You can find the challenge here: <a href="https://fly.io/dist-sys/3a/">https://fly.io/dist-sys/3a/</a></p>
<p>In this first part of the broadcast challenge, we will make a system with a single node, so that we don't have to worry about inter-node communication and we can just focus on the interfaces to communicate with clients.</p>
<p>This first part is very similar to the previous exercises and doesn't involve anything new so we won't detail the code here. However we will discuss some interesting points, and if you need you can always check the solution code in the repo for a working implementation.</p>
<p>The test command should be </p>
<pre><code class="language-bash">~/maelstrom/maelstrom test -w broadcast --bin target/debug/broadcast_1 --node-count 1 --time-limit 20 --rate 10
</code></pre>
<h2 id="the-messages"><a class="header" href="#the-messages">The messages</a></h2>
<p>Once again we are presented with a list of messages our application needs to know about. <code>read</code> and <code>broadcast</code> are pretty straightforward, but <code>topology</code> is a bit different. </p>
<p>This <code>topology</code> message is sent once to each node in the network at the start by maelstrom and suggests a topology for each node to use. A topology is a graph describing which nodes connect with which other nodes. In the real world, this would be dictated by communication latencies, network hops, or other parameters. In fact, there exists a bunch of strategies to define the optimal topology to ensure the best performances. In the context of Maelstrom, every node can speak with every node and you are not constrained by the topology that your node receive, you can perfectly ignore it or change it. Today we will actually use it and each node will act as if it only knows about the nodes in the topology it receives.</p>
<p>Note that you need to acknowledge the topology message as well.</p>
<p>In this first part, since there is only one node in the network, we won't use the topology, but to prepare for part 2, you will probably need to store it somewhere so that the node can reference it during the rest of its lifespan.</p>
<p>Since you will also need to keep track of all the messages the node knows about, I suggest you implement a structure dedicated to storing the state of the node.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4b-multi-node-broadcast"><a class="header" href="#chapter-4b-multi-node-broadcast">Chapter 4b: Multi node broadcast</a></h1>
<p>You can find the challenge here: <a href="https://fly.io/dist-sys/3b/">https://fly.io/dist-sys/3b/</a></p>
<p>This challenge is where the real fun begins! Let's make our nodes communicate with each others.</p>
<h2 id="a-bit-of-theory"><a class="header" href="#a-bit-of-theory">A bit of theory</a></h2>
<h3 id="gossip"><a class="header" href="#gossip">Gossip</a></h3>
<p>To do so, we will use one of the staples of distributed systems: Gossip. From <a href="https://en.wikipedia.org/wiki/Gossip_protocol#:~:text=A%20gossip%20protocol%20or%20epidemic,all%20members%20of%20a%20group.">the wikipedia page</a>: </p>
<blockquote>
<p>A gossip protocol or epidemic protocol is a procedure or process of computer peer-to-peer communication that is based on the way epidemics spread. Some distributed systems use peer-to-peer gossip to ensure that data is disseminated to all members of a group.</p>
</blockquote>
<p>By designing a broadcast system, the challenge encourages us to develop a leaderless architecture: we will develop a peer-to-peer architecture, which can be be very similar to what is used in Cassandra for instance. Every node is doing the same work and if you send a message to node A and then ask node B to get this same message, it should eventually be able to provide it to you. The word eventually is important, these systems are generally &quot;eventually consistent&quot; because it takes time to propagate state updates to all nodes. Essentially, this means that given enough time (a reasonable amount of it) after the last state update, all nodes should have the same state.</p>
<p>For now we will implement an inefficient but simple version of gossip: whenever each node decides to gossip, it will send all the data it knows of to all other nodes. We will improve this in the next parts of this challenge.</p>
<h3 id="scheduling-gossip-with-an-actors-model"><a class="header" href="#scheduling-gossip-with-an-actors-model">Scheduling gossip with an actors model</a></h3>
<p>Next important thing is to decide when we want to gossip. We could do it after every message we receive but this seems terribly wasteful. Since we are ok with eventual consistency, let's gossip on a timer, every 100ms for instance.</p>
<p>This means that we will need to change our main loop so that every so often, we pause message-listening to gossip what we know to other nodes in our topology. There are multiple way to implement this interleaved scheduling of two I/O tasks (waiting on a timer and reading new messages from stdin): we could leverage async Rust to do so with high performances, but this is far too complex for today's workshop, so instead we will use a simple multi-threaded approach by building an actors model.</p>
<p>An actor model is a model in which each actor (generally a thread) is responsible for one part of the work, and each actor can only communicate with other actors through the use of messages. Actors models are very powerful and can make the writing of multi-threaded code much easier and less risky, since they essentially remove the need for lock-based synchronization. However, they also can often results in bottlenecks so they are not always the best choice. However for our use case it will work well.</p>
<h2 id="walkthrough-2"><a class="header" href="#walkthrough-2">Walkthrough</a></h2>
<p>In this part we will need to learn how to do new stuff in Rust: writing multi-threaded code in particular so we will start from the content of the solution of the previous part and elaborate on it progressively while explaining everything.</p>
<p>We will have 3 different actors (so 2 additional threads to the main thread):</p>
<ul>
<li><strong>actor 1:</strong> run a timer and periodically ask for gossip to happen</li>
<li><strong>actor 2:</strong> read messages from input</li>
<li><strong>actor 3:</strong> consume the output of the previous two and run the main loop (i.e. send messages).</li>
</ul>
<p>Let's start by representing the messages our actors will send each others (we will call them <code>Event</code> to avoid confusion with the <code>Message</code> struct):</p>
<pre><code class="language-rust ignore">/// This defines the possible events on which our main loop can react, within our actor system
enum Event {
    /// this event means there is no more input messages to read from Maelstrom
    Eof,
    /// this event means it's time to do some gossip
    TimeToGossip,
    /// this event means we have received a message
    MessageReceived(Message&lt;BroadcastPayload&gt;),
}</code></pre>
<p>As you can see, we use an enum with 3 variants. The first one will be used to mark the end of the input and properly shut down other threads.</p>
<p>The second one will be emitted by our first actor at a periodic interval</p>
<p>The third one encapsulates a Message and is sent by the actor that consumes from stdin.</p>
<p>Essentially, we will have this architecture:</p>
<pre><code class="language-ignore">         ┌─────────┐
         │         │
timer ──►│ actor 1 ├─┐
         │         │ │                ┌─────────┐
         └─────────┘ │ Channel&lt;Event&gt; │         │
                     ├───────────────►│ actor 3 ├──► stdout
         ┌─────────┐ │                │         │
         │         │ │                └─────────┘
stdin ──►│ actor 2 ├─┘
         │         │
         └─────────┘
</code></pre>
<p>As you can see, we will use a channel to send and receive messages, we need a channel that allows multiple producers and single receiver (an MPSC channel in Rust lingua, Multiple Producers, Single Consumer). To declare such a channel, we need to write this code:</p>
<pre><code class="language-rust ignore">// we will use an actor channel to handle scheduling of both gossiping and reading and
// responding to messages.
// create a channel that we will use to make our actors communicate
let (tx, rx) = std::sync::mpsc::channel::&lt;Event&gt;();</code></pre>
<p>We can again observe the turbofish syntax used to specify which type of things we want to send through our channel. Sum types are such a natural fit to describe a message going through a channel: you have a single type, that can describe several variants, each carrying their own payload.
When calling this <code>channel</code> function we get its two handles, <code>tx</code> (for transmit) to send events and <code>rx</code> (for receive) to receive events.</p>
<h3 id="actor-1-sending-gossip-events"><a class="header" href="#actor-1-sending-gossip-events">Actor 1: sending Gossip events</a></h3>
<p>Now we only need to write our actors. Let's start with actor 1, a thread that will loop and periodically send <code>Event::TimeToGossip</code> events in the channel. The code to do so looks like this</p>
<pre><code class="language-rust ignore">use std::time::Duration;
// ...

// clone the tx handle so that we keep one for the actor 2 as well
let tx_clone = tx.clone();
// spawn a thread generating periodic gossip events, our first actor
let gh = std::thread::spawn(move || loop {
    if tx_clone.send(Event::TimeToGossip).is_err() {
        // other side hung up, let's finish the loop
        break;
    };
    std::thread::sleep(Duration::from_millis(250));
});</code></pre>
<p>We can see here an example of a &quot;closure&quot;, i.e. an anonymous function that can capture data from its invocation context. This is very similar to python lambdas. The syntax to declare a closure is </p>
<pre><code class="language-ignore">[optional: move] |[args...]| [expression]
</code></pre>
<p>Let's start with a simple example:</p>
<pre><code class="language-rust ignore">let a: u8 = 23;
let closure = |b: u8| a + b;

println!(&quot;The result is {}&quot;, closure(7));</code></pre>
<p>This will print <code>30</code>. This closure &quot;captures&quot; the a variable from its outer scope, and sums it with its parameter b. In the context of the closure, <code>a</code> would be a <code>&amp;u8</code> as closures capture variables by reference by default. If we want to capture outer variables by moving them into the closure scope instead of taking references, we prefix the closure syntax with the <code>move</code> keyword. In that case, <code>a</code> would be a <code>u8</code> within the closure, and after invoking it, you could no longer use <code>a</code> in the outer scope as it would have been moved away (consumed by the closure if you want).</p>
<p>Let's go back to our original closure that defines our thread:</p>
<pre><code class="language-rust ignore">move || loop {
    if tx_clone.send(Event::TimeToGossip).is_err() {
        // other side hung up, let's finish the loop
        break;
    };
    std::thread::sleep(Duration::from_millis(250));
}</code></pre>
<p>We use <code>move</code> because we cannot take references and send them to another thread (this is not memory safe and rust won't let you do it). We capture the <code>tx_clone</code> handle (by value because of the <code>move</code> modifier), and in an infinite loop (the <code>loop</code> keyword is syntactic sugar for <code>while true</code>), we send a <code>Event::TimeToGossip</code> event in the channel and then sleep the thread for 250ms.
If the send call returns an error, we break out of the loop and therefore finish the thread. This will happen when the other side of the channel hangs up and we will use this mechanism to properly finish our threads and shutdown our application.</p>
<h3 id="actor-2-reading-stdin-for-incoming-messages"><a class="header" href="#actor-2-reading-stdin-for-incoming-messages">Actor 2: reading stdin for incoming messages</a></h3>
<p>Let's show the code for the second actor and then comment it:</p>
<pre><code class="language-rust ignore">// spawn a thread forwarding input into the channel, our second actor
let ih = std::thread::spawn(move || {
    // get a new input interface, this can hang if another one already exists somewhere...
    let mut input = InputInterface::default();

    for msg in input.iter::&lt;BroadcastPayload&gt;() {
        let msg = msg.expect(&quot;Should be able to get message from stdin&quot;);
        if tx.send(Event::MessageReceived(msg)).is_err() {
            break;
        };
    }
    // no more messages, send EOF for proper shutdown
    tx.send(Event::Eof).unwrap();
});</code></pre>
<p>There is not much more going here but I'll detail a few points still:</p>
<ul>
<li>we don't clone <code>tx</code> once more, we directly captures the original <code>tx</code> into this thread since we won't need it anymore for other actors.</li>
<li>once we have read all the messages from stdin, we send the special <code>Event::Eof</code> event in the channel to tell actor 3 that it's time to do shutdown. Once actor 3 shuts down, it will automatically signal actor 1 to shutdown as well by deleting the <code>rx</code> end of the channel.</li>
<li>We need to acquire our mutable input interface within the thread scope. This is because an input interface is actually a mutex over stdin (to prevent several threads from accessing it simultaneously which would read garbage data), and a mutex cannot be sent safely to another thread. To make it work, we also need to change our Maelstrom init call to immediately drop the input handle we get from it and let this new thread acquire the lock itself. So you will need to change your init call to something like this: <code>let (mut node_metadata, _, mut output) = Maelstrom::init()?;</code> where <code>_</code> is a special sigil which prevents the binding from happening and that automatically drops the returned value.</li>
</ul>
<p>at this point, your main function should look something like this:</p>
<pre><code class="language-rust ignore">// ... imports ...

fn main() -&gt; anyhow::Result&lt;()&gt; {
    // init our node by getting its metadata and an output and input interface to communicate
    // here we drop the input interface as soon as we get it to release the lock before opening a
    // new one in a separate thread.
    let (mut node_metadata, _, mut output) = Maelstrom::init()?;

    // init the state
    let mut state = State {
        messages: HashSet::new(),
        topology: None,
    };

    // we will use an actor channel to handle scheduling of both gossiping and reading and
    // responding to messages.
    // create a channel that we will use to make our actors communicate
    let (tx, rx) = std::sync::mpsc::channel::&lt;Event&gt;();
    let tx_clone = tx.clone();

    // spawn a thread generating periodic gossip events, our first actor
    let gh = std::thread::spawn(move || loop {
        if tx_clone.send(Event::TimeToGossip).is_err() {
            // other side hung up, let's finish the loop
            break;
        };
        std::thread::sleep(Duration::from_millis(250));
    });

    // spawn a thread forwarding input into the channel, our second actor
    let ih = std::thread::spawn(move || {
        // get a new input interface, this can hang if another one already exists somewhere...
        let mut input = InputInterface::default();

        for msg in input.iter::&lt;BroadcastPayload&gt;() {
            let msg = msg.expect(&quot;Should be able to get message from stdin&quot;);
            if tx.send(Event::MessageReceived(msg)).is_err() {
                break;
            };
        }
        // no more messages, send EOF for proper shutdown
        tx.send(Event::Eof).unwrap();
    });

    // we now need to write the third actor in the main thread
    todo!()
}</code></pre>
<h3 id="actor-3-consuming-events-and-acting-on-it"><a class="header" href="#actor-3-consuming-events-and-acting-on-it">Actor 3: consuming events and acting on it</a></h3>
<p>Finally we will write our third actor that will simply consume events from the channel and react on them. On a gossip event, we will send messages to other nodes to let them know of the data we know. On a message event, we will respond to this message, possibly using the data we have in our state. Finally, on an eof event, we will simply stop the program properly.</p>
<p>So let's start coding this by looping over the channel content and matching on the event type:</p>
<pre><code class="language-rust ignore">// main loop: for each event we receive through the channel (our last actor)
for event in rx {
    match event {
        // match on the type of event received
        Event::Eof =&gt; {
            // rx is automatically dropped once we get out of the loop because we implicitly called
            // into_iter() on it to buils the loop, which consumes self.
            break;
        }
        Event::TimeToGossip =&gt; {
            // it's time to gossip, let's send messages to all nodes within our reach
            todo!()
        }
        Event::MessageReceived(msg) =&gt; {
            // match on the type of payload within the message, these are variants of the BroadcastPayload enum
            match &amp;msg.body.payload {
                BroadcastPayload::Gossip { known } =&gt; {
                    // we received a gossip message from another node, let's update our known data
                    todo!()
                }
                BroadcastPayload::Topology { topology } =&gt; {
                    state.topology = Some(topology.clone());
                    output.send_msg(msg.to_response(
                        Some(node_metadata.get_next_msg_id()),
                        BroadcastPayload::TopologyOk,
                    ))?
                }
                // we are not supposed to receive a TopologyOk message, let's panic when it happens
                BroadcastPayload::TopologyOk =&gt; {
                    panic!(&quot;TopologyOk message shouldn't be received by a node&quot;)
                }
                BroadcastPayload::Broadcast { message } =&gt; {
                    state.messages.insert(*message);
                    output.send_msg(msg.to_response(
                        Some(node_metadata.get_next_msg_id()),
                        BroadcastPayload::BroadcastOk,
                    ))?
                }
                // we are not supposed to receive a BroadcastOk message, let's panic when it happens
                BroadcastPayload::BroadcastOk { .. } =&gt; {
                    panic!(&quot;BroadcastOk message shouldn't be received by a node&quot;)
                }
                BroadcastPayload::Read =&gt; output.send_msg(msg.to_response(
                    Some(node_metadata.get_next_msg_id()),
                    BroadcastPayload::ReadOk {
                        messages: state.messages.clone(),
                    },
                ))?,
                // we are not supposed to receive a ReadOk message, let's panic when it happens
                BroadcastPayload::ReadOk { .. } =&gt; {
                    panic!(&quot;ReadOk message shouldn't be received by a node&quot;)
                }
            }
        }
    };
}

// let's join on both threads for proper exit
ih.join().unwrap();
gh.join().unwrap();</code></pre>
<p>In case of an Eof, we are just breaking out of the outer loop and then calling <code>join()</code> on both our thread handles to wait until they have complete and properly exit our program.</p>
<p>In case of a message received, we do the same as we did in the previous part, except now this time we support a new payload type: <code>BroadcastPayload::Gossip</code>. This is a one shot message that don't expect a response, and that looks like this:</p>
<pre><code class="language-rust ignore">/// Defines the payload we want to send to clients in the broadcast challenge
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = &quot;type&quot;)]
#[serde(rename_all = &quot;snake_case&quot;)]
enum BroadcastPayload {
    // ... snip ...
    // we will use this message to communicate gossip in-between nodes of the cluster
    Gossip {
        known: HashSet&lt;usize&gt;,
    },
}</code></pre>
<p>Now we just need to implement how to react on such a gossip message received, and how to react to a <code>TimeToGossip</code> event.</p>
<p>For the latter we will just send a <code>Gossip</code> message with the messages we have stored in our state, and for the former we will update our state with the unknown messages we received:</p>
<pre><code class="language-rust ignore">// ...
Event::TimeToGossip =&gt; {
    // it's time to gossip, let's send messages to all nodes within our reach
    if let Some(topology) = state.topology.as_ref() {
        for n in topology.get(&amp;node_metadata.node_id).context(format!(
            &quot;Node {} should appear in the topology&quot;,
            node_metadata.node_id
        ))? {
            // for now we send the full list of messages we know, which is suboptimal
            output.send_msg(Message {
                src: node_metadata.node_id.clone(),
                dst: n.clone(),
                body: Body {
                    msg_id: None,
                    in_reply_to: None,
                    payload: BroadcastPayload::Gossip {
                        known: state.messages.clone(),
                    },
                },
            })?;
        }
    }
    // if we don't have the topology yet, let's skip gossiping for now.
}
// ...</code></pre>
<pre><code class="language-rust ignore">// ...
match &amp;msg.body.payload {
    BroadcastPayload::Gossip { known } =&gt; {
        // we received a gossip message from another node, let's update our known data
        state.messages = state.messages.union(known).copied().collect();
    }
// ...
}</code></pre>
<p>And that's all for this challenge, we implemented a complete actor model based on multithreading to act on several types of events coming from various sources in our program.</p>
<h3 id="testing-our-code-1"><a class="header" href="#testing-our-code-1">Testing our code</a></h3>
<p>It's now time to build and test our code to verify if we succeeded. First let's run <code>cargo build</code> to build a debug binary of our program. This should generate a new binary: <code>target/debug/broadcast_2</code>.</p>
<p>Let's now invoke Maelstrom on it to see if we solved the challenge:</p>
<pre><code class="language-bash">~/maelstrom/maelstrom test -w broadcast --bin ./target/debug/broadcast_2 --node-count 5 --time-limit 20 --rate 10
</code></pre>
<p>If everything goes well, you should see</p>
<pre><code class="language-ignore">Everything looks good! ヽ(‘ー`)ノ
</code></pre>
<p>Congrats! In the next parts, we will work at making our gossip smarter and fault tolerant.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-a-cargo-cheatsheet"><a class="header" href="#appendix-a-cargo-cheatsheet">Appendix A: Cargo Cheatsheet</a></h1>
<p><code>cargo</code> is the main interface with rust you will use. This is a CLI tool that exposes all commands to check, build, format, and release your code, and that handles interacting with the compiler <code>rustc</code> for you. Think of it as <code>poetry</code> for python or <code>npm</code> for node.</p>
<p>Here is a quick cheatsheet of useful commands:</p>
<pre><code class="language-bash">cargo build # build a debug binary/lib
cargo run # build and run a debug binary/lib
cargo {build|run} --release # same but for release binary/lib

cargo test # run all tests of your project
cargo doc # build a static website serving the documentation of your project

cargo check # check correctness of your code, i.e. does it compile ?
cargo fmt # run the formatter on your code
cargo clippy # run the linter on your code, note that this is a superset of cargo check

cargo add &lt;crate_name&gt; # add a crate to your project, i.e. a dependency
cargo remove &lt;crate_name&gt; # remove a crate from your project
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
